### [1049. 最后一块石头的重量 II - 力扣（Leetcode）](https://leetcode.cn/problems/last-stone-weight-ii/description/)

有一堆石头，用整数数组 `stones` 表示。其中 `stones[i]` 表示第 `i` 块石头的重量。

每一回合，从中选出**任意两块石头**，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：

- 如果 `x == y`，那么两块石头都会被完全粉碎；
- 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。

最后，**最多只会剩下一块** 石头。返回此石头 **最小的可能重量** 。如果没有石头剩下，就返回 `0`。

**示例 1：**

```
输入：stones = [2,7,4,1,8,1]
输出：1
解释：
组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，
组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，
组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，
组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。
```

**示例 2：**

```
输入：stones = [31,26,33,21,40]
输出：5
```

**提示：**

- `1 <= stones.length <= 30`
- `1 <= stones[i] <= 100`

**题解思路：**

**分成两堆，利用01背包求其中一个堆，然后两堆之差就是答案**

**为什么可以转01的原因**： 整个题目，每个回合数两两抽出来比较，两个数之差将被再一次扔到数组里面，继续上面的过程。每个回合都会丢失掉两个数字，加入一个新的数字，这个数字就是两个数的差。相当于来说，就是少了`a`和`b`，但是多了一个`a-b`，`a`，`b`就此消失，但是在下一回合，`a-b`可能又被抓出去`pk`，`pk`后`a-b`就此再消失了，又产生了新的一个差。那么每一步来说，其实就相当于`a`，`b`没有真正意义消失。 到了最后一回合，我们可以知道，其实找出两个最接近的数字堆。 再举个例子：

`[31,26,33,21,40]` 

`1：40-21 [19,26,31,33] `

`2: 31-(40-21) [12,26,33] `

`3: 33-(31-(40-21)) [21,26] `

`4: 26-(33-(31-(40-21))) [5]`

总： `（26+31+21） - （40+33）` 这就是找出两个总和接近的两个堆。 如何让两个堆接近呢？ 那就是沿着中间分两半，找左右各自那一半，那么思路就来到了找出一半堆这里。那么就自然而然地来到取不取的问题，就是`01`背包问题。

需要确定以下四点：

- 有几个物品可供选择：`stones.size()`
- 背包的总容量是多少：`accumulate(stones.)/2`
  - 因为题目是要求出现两个子集，其和相等都为`sum/2`
- 物品重量如何表示：`stones[i]`
- 物品价值如何表示：`stones[i]`

**动归五部**

- 确定`dp`数组及其含义
  - `dp[i][j]`代表从`[0, i]`中选择一件物品放入容量大小为`j`的背包所能获得的最大价值
- 确定递推公式
- 确定`dp`数组的初始化
- 确定递推顺序
  - 一维需要注意遍历容量时是逆序遍历
- 手动推导`dp`数组

**完整代码：**

```c++
class Solution {
public:
// 如何与背包取得联系？  本题求最小的可能重量  。。。 呆了
// 是这样的，将该组石头尽可能的分为相等的两组，两组总和的差值就是结果，对于一维dp，dp[j]就是容量为j的最大价值，此题背包大小取sum/2，令其为target，则dp[target]就代表其中一个堆
    // 确定物品数量  stones.size()  ->  i
    // 确定背包总大小  ??
    // 确定单个物品重量  stones[i]
    // 确定单个物品的价值  stones[i]
    int lastStoneWeightII(vector<int>& stones) {
        // 二维dp
        // if(stones.size() == 1) return stones[0];
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int target = sum/2;
        vector<vector<int> > dp(stones.size(), vector<int>(target + 1, 0));
        //初始化
        for(int j = stones[0]; j <= target; j++){
            dp[0][j] = stones[0];
        }
        
        //动态规划
        for(int i = 1; i < stones.size(); i++){
            for(int j = 1; j <= target; j++){
                if(j < stones[i]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - stones[i]] + stones[i]);
            }
        }
        
        return (sum - dp[stones.size() - 1][target]) - dp[stones.size() - 1][target];  // 与416的不同之处
    }
};

// 此题获得的动态规划的理解 -> 对于重量与价值是同一东西的题目，dp[target] 就会接近target，文字来说就是此类题目使用动态规划可以从给定数组中找到一系列的值来接近target
```

