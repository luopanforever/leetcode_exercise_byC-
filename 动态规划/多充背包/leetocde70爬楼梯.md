[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/#)

假设你在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**示例 1：**

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

**示例 2：**

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：**

- `1 <= n <= 45`

#### **题解思路：**

转化为完全背包问题：

- 每次可以选择爬一个楼梯或者爬两个楼梯，就相当于有一个`nums`数组，里面装了两个值，一个值是`1`，一个值是`2`，从这里面取值出来可以多次取，将j背包装满有多少种方法

**关键词：**

完全背包、动态规划

根据题意，假设一个数组`nums{1, 2}`

- 物品数量 ： `nums.size()`
- 背包大小：`n`
- 物品重量：`nums[i]`
- 物品价值：`nums[i]`

**`dp`数组的含义：**

- `dp[j]`数组的含义` ->` 装满j背包的方法有多少种` ->` 爬到j阶楼梯的方法有多少种

**初始化:**

-  初始化 求方法数量初始化`dp[0] = 1`

**遍历顺序：**

多重背包从前到后，`[1,2]、[2,1]`是不同的解集，所以先遍历背包，再遍历物品

**完整代码:**

```c++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> nums{1,2};
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for(int j = 0; j <= n; j++){
            for(int i = 0; i < nums.size(); i++){
                if(j >= nums[i])
                    dp[j] += dp[j - nums[i]];
            }
        }
        return dp[n];
    }
};
```

